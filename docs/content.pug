include mixins.pug

h2 Overview

include:markdown-it overview.md

h2 API

h3#semigroup Semigroup
p Import with.
pre
  code.language-javascript.
    import {combine} from "jabz/semigroup";

+fn('combine', '<A extends Semigroup<A>>(a: A, b: A): A')
  div.description
    p Combines two members of the same semigroup by using their combine method.
  pre
    code.language-javascript.
      combine(sum(3), sum(5)); //=> Sum(8)
      combine("Hello ", "there"); //=> "Hello there"
      combine([1, 2, 3], [4, 5]); //=> [1, 2, 3, 4, 5]

h3#monoid Monoid
p Import with.
pre
  code.language-javascript.
    import * as Monoid from "jabz/monoid";

+fn('identity', '<M extends Monoid<M>>(m: MonoidDictionary<M>): M')
  div.description
    p Takes a monoid dictionary and returns the identity element of the monoid. Alternatively it takes a constructor of one of the native monoid instances.
  pre
    code.language-javascript.
      identity(Sum); //=> Sum(0)
      identity(Array); //=> []
      identity(String); //=> ""

h3#functor Functor
| Import with.
pre
  code.language-javascript.
    import * as Functor from "jabz/functor";

+fn('map', '<F extends Functor, A, B>(f: (a: A) => B, a: F<A>): F<B>')
  div.description
    p Maps a function over a functor.
  pre
    code.language-javascript.
      map((n) => n * n, just(3)); //=> just(9)
      map((n) => n * n, [1, 2, 3]); //=> [1, 4, 9]

+fn('mapTo', '<F extends Functor, A, B>(b: B, as: F<A>): F<B>')
  div.description
    p Replaces each value inside the functor with b.
  pre
    code.language-javascript.
      mapTo(2, just(3)); //=> just(2)
      mapTo(4, [1, 2, 3]); //=> [4, 4, 4]

h3#applicative Applicative
p Import with.
pre
  code.language-javascript.
    import * as Applicative from "jabz/applicative";

+fn('of', '<A, F extends Applicative>(d: ApplicativeDictionary, a: A): F<A>)')
  :markdown-it
    Wraps a value in an applicative. This function is also known as `pure` and `return`.

    ```javascript
    of(Maybe, 12); //=> just(12)
    of(Array, 12); //=> [12]
    ```

+fn('ap', '<A, B, F extends Applicative>(fa: F<(a: A) => B>, ba: F<A>): F<B>')
  :markdown-it
    Applies stuff.

+fn('lift', '<F extends Applicative>(f: (?) => R, ...args: F<?>[]): F<A>')
  :markdown-it

    Takes a function from `n` arguments, `n` applicatives with values
    matching the function and applies the function inside the applicatives.

    ```javascript
    lift((a, b, c) => a * b + c, just(4), just(2), just(3)); //=> just(11)
    lift((a, b, c) => a * b + c, just(4), nothing, just(3)); //=> nothing
    ```

+fn('seq', '<A, B, F extends Applicative>(a: F<A>, b: F<B>): F<B>')
  :markdown-it
    Sequences actions from left to right, i.e. `a` before `b`, discarding the value of `a`.

h3#monad Monad
p Import with.
pre
  code.language-javascript.
    import * as Monad from "jabz/monad";

+fn('flatten', '<A, M extends Monad>(m: M<M<A>): M<A>')
  div.description
    p Removes one level of nesting from a monad inside a monad.
  pre
    code.language-javascript.
      flatten(just(just(1))); //=> just(1)

+fn('chain', '<A, B, M extends Monad>(f: (a: A) => M<B>, m: M<A>): M<B>')
  div.description
    p Monadic chain.
  pre
    code.language-javascript.
      flatten(just(just(1))); //=> just(1)

+fn('go', '<M extends Monad>(gen: () => Iterator<M<any>>): M<any>')
  :markdown-it
    Do-notation powered by generator functions.

    ```javascript
    go(function*() {
      const a = yield just(1);
      const b = yield just(3);
      const c = yield just(2);
      return just(a + b + c);
    }); //=> just(6)

    go(function*() {
      const a = yield just(1);
      const b = yield nothing;
      const c = yield just(2);
      return just(a + b + c);
    }); //=> nothing
    ```

+fn('fgo', '<M extends Monad>(gen: (..args) => Iterator<M<any>>): (..args) => M<any>')
  :markdown-it

    A nifty shortcut for creating a function that uses go-notation.
    The arguments to the function are passed directly to the generator
    function.

    ```javascript
    const fgoExample = fgo(function*(x, y, z) {
      const a = yield just(x);
      const b = yield just(y);
      const c = yield just(z)
      return just(a + b + c);
    });
    fgoExample(1, 2, 3); //=> just(6)
    ```

h3#foldable Foldable
| Import with.
pre
  code.language-javascript.
    import * as Foldable from "jabz/foldable";

+fn('foldr', '<A, B>(f: (a: A, b: B) => B, init: B, a: Foldable<A> | A[]): B')
  div.description
    p Performs a strict right fold over a foldable.

+fn('size', '(a: Foldable<any>): number')
  div.description
    p Returns the size of a foldable.

+fn('take', '(n: number, t: Foldable<A>): A[]')
  div.description
    p Returns an array of the first n elements in the foldable.

+fn('find', '(f: (a: A) => boolean, t: Foldable<A>): Maybe<A>')
  div.description
    p Returns the first element in the foldable that satisfies the predicate.
    pre
      code.language-javascript.
        const isEven = (n) => n % 2 === 0;
        find(isEven, fromArray([1, 3, 4, 5, 6, 7])); //=> just(4)
        find(isEven, fromArray([1, 3, 5, 7])); //=> nothing

+fn('findLast', '(f: (a: A) => boolean, t: Foldable<A>): Maybe<A>')
  div.description
    p Returns the last element in the foldable that satisfies the predicate.
    pre
      code.language-javascript.
        findLast(isEven, fromArray([1, 3, 4, 5, 6, 7])); //=> just(6)
        findLast(isEven, fromArray([1, 3, 4, 5, 6, 7])); //=> just(6)

+fn('toArray', '(t: Foldable<A>): A[]')
  div.description
    p Converts a foldable to an array.

+fn('sequence_', '<A extends Applicative>(d: ApplicativeDictionary, t: Foldable<A<any>>): A<{}>')
  :markdown-it
    Sequences applicatives in the foldable from left to right and discarding the result.

+fn('foldrM', '<A, B, M extends Monad>(f: (a: A, b: B) => M<B>, mb: M<B>, t: Foldable<A>): M<B>')
  div.description
    p Monadic right fold. This function is similair to foldr. The difference is that the accumulator function returns a monadic value and that the final result is in the same monad.
  pre
    code.language-javascript.
      const divide = (a, b) => a === 0 ? nothing : just(b / a);
      foldrM(divide, just(100), fromArray([10, 5])); //=> just(2)
      foldrM(divide, just(100), fromArray([5, 0])); //=> nothing

h3#traversable Traversable
| Import with.
pre
  code.language-javascript.
    import * as Traversable from "jabz/traversable";

+fn('sequence', '<A, T extends Traversable, F extends Applicative>(a: ApplicativeDictionary, t: T<F<A>>): F<T<A>>')
  div.description
    :markdown-it
      Takes a traversable with applicatives inside and "flips" the nesting so that the applicative ends up on the outside and the traversable on the inside.

      In the example below the applicative `Maybe` the traversable created by `fromArray`.
      Sequence turns them inside out so that `just` floats from the inside to the outside.
  pre
    code.language-javascript.
      sequence(Maybe, fromArray([just(1), just(2), just(3)])); //=> just(fromArray([1, 2, 3]))

+fn('traverse', '<A, B, T extends Traversable, F extends Applicative>(a: ApplicativeDictionary, f: (a: A) => F<B>, t: T<A>): F<T<B>>')
  div.description
    p Traverse.
  pre
    code.language-javascript.
      traverse(Maybe, just, fromArray([1, 2, 3])); //=> just(fromArray([1, 2, 3]))

h2 Instances

include maybe.pug
include either.pug
include conslist.pug
include infinitelist.pug

h2 Specification

h3 Semigroup

table.spec-table
  tr
    td Description
    td
      p A semigroup represents things that can be combined. That is, two objects of the same semigroups can be combined into one object of the semigroup. In other words semigroups are things that can be composed.
      p Examples are many. For instance numbers can be combined by adding them together, lists can be combined by concatenating them and images can be combined by overlaying them.
  tr
    td Methods
    td
      +method('combine', '(a: A) => A')

h3 Monoid
table.spec-table
  tr
    td Description
    td Monoid extends semigroups with an identity element.
  tr
    td Methods
    td
      +method('identity', '() => A')
  tr
    td Laws
    td.method m.combine*(m.identity()) === m.identity().combine(m) === m
