include mixins.pug

h2 Overview

include:markdown-it overview.md

h2 API

p API documentation for Jabz.

+h3-section('Semigroup')

p Import with.
pre
  code.language-javascript.
    import {combine} from "jabz/semigroup";

+fn('combine', '<A extends Semigroup<A>>(a: A, b: A): A')
  div.description
    p Combines two members of the same semigroup by using their combine method.
  pre
    code.language-javascript.
      combine(sum(3), sum(5)); //=> Sum(8)
      combine("Hello ", "there"); //=> "Hello there"
      combine([1, 2, 3], [4, 5]); //=> [1, 2, 3, 4, 5]

+h3-section('Monoid')
p Import with.
pre
  code.language-javascript.
    import * as Monoid from "jabz/monoid";

+fn('identity', '<M extends Monoid<M>>(m: MonoidDictionary<M>): M')
  div.description
    p Takes a monoid dictionary and returns the identity element of the monoid. Alternatively it takes a constructor of one of the native monoid instances.
  pre
    code.language-javascript.
      identity(Sum); //=> Sum(0)
      identity(Array); //=> []
      identity(String); //=> ""

+h3-section('Functor')
| Import with.
pre
  code.language-javascript.
    import * as Functor from "jabz/functor";

+fn('map', '<F extends Functor, A, B>(f: (a: A) => B, a: F<A>): F<B>')
  div.description
    p Maps a function over a functor.
  pre
    code.language-javascript.
      map((n) => n * n, just(3)); //=> just(9)
      map((n) => n * n, [1, 2, 3]); //=> [1, 4, 9]

+fn('mapTo', '<F extends Functor, A, B>(b: B, as: F<A>): F<B>')
  div.description
    p Replaces each value inside the functor with b.
  pre
    code.language-javascript.
      mapTo(2, just(3)); //=> just(2)
      mapTo(4, [1, 2, 3]); //=> [4, 4, 4]

+h3-section('Applicative')
p Import with.
pre
  code.language-javascript.
    import * as Applicative from "jabz/applicative";

+fn('of', '<A, F extends Applicative>(d: ApplicativeDictionary, a: A): F<A>)')
  :markdown-it
    Wraps a value in an applicative. This function is also known as `pure` and `return`.

    ```javascript
    of(Maybe, 12); //=> just(12)
    of(Array, 12); //=> [12]
    ```

+fn('ap', '<A, B, F extends Applicative>(fa: F<(a: A) => B>, ba: F<A>): F<B>')
  :markdown-it
    Takes two applicatives of the same type. The first must contain a
    function from `A` and the second an `A`. The function is then
    applied to the value and a new applicative is returned.

+fn('lift', '<F extends Applicative>(f: (?) => R, ...args: F<?>[]): F<A>')
  :markdown-it

    Takes a function from `n` arguments, `n` applicatives with values
    matching the function and applies the function inside the applicatives.

    ```javascript
    lift((a, b, c) => a * b + c, just(4), just(2), just(3)); //=> just(11)
    lift((a, b, c) => a * b + c, just(4), nothing, just(3)); //=> nothing
    ```

+fn('seq', '<A, B, F extends Applicative>(a: F<A>, b: F<B>): F<B>')
  :markdown-it
    Sequences actions from left to right, i.e. `a` before `b`, discarding the value of `a`.

+h3-section('Monad')
p Import with.
pre
  code.language-javascript.
    import * as Monad from "jabz/monad";

+fn('flatten', '<A, M extends Monad>(m: M<M<A>): M<A>')
  div.description
    p Removes one level of nesting from a monad inside a monad.
  pre
    code.language-javascript.
      flatten(just(just(1))); //=> just(1)

+fn('chain', '<A, B, M extends Monad>(f: (a: A) => M<B>, m: M<A>): M<B>')
  div.description
    :markdown-it

      Values in `m` are passed to `f` and `f` returns a new monadic
      value that is joined with the former. This operation is
      sometimes called `flatMap` and other times `>>=`.

      `m.chain(f)` is equal to `m.map(f).flatten()`.

      ```javascript
      chain((m) => safeDiv(12, m), just(3)); // just(4)
      ```

+fn('go', '<M extends Monad>(gen: () => Iterator<M<any>>): M<any>')
  :markdown-it
    Do-notation powered by generator functions.

    The example below demonstrates the use of go-notation with the
    `Maybe` monad. Note that the yielded values are all in the monad
    and that the variables becomes bound to the value inside the monad.

    ```javascript
    const safeDiv = (n, m) => m === 0 ? nothing : just(n / m);
    go(function*() {
      const a = yield find(isEven, list1);
      const b = yield find(isEven, list2);
      const c = yield safeDiv(a, b)
      return a + b + c;
    });
    ```

+fn('fgo', '<M extends Monad>(gen: (..args) => Iterator<M<any>>): (..args) => M<any>')
  :markdown-it

    A nifty shortcut for creating a function that uses go-notation.
    The arguments to the function are passed directly to the generator
    function.

    ```javascript
    const fgoExample = fgo(function*(x, y, z) {
      const a = yield just(x);
      const b = yield just(y);
      const c = yield just(z)
      return a + b + c;
    });
    fgoExample(1, 2, 3); //=> just(6)
    ```

+h3-section('Foldable')
| Import with.
pre
  code.language-javascript.
    import * as Foldable from "jabz/foldable";

+fn('foldr', '<A, B>(f: (a: A, b: B) => B, init: B, a: Foldable<A> | A[]): B')
  div.description
    p Performs a strict right fold over a foldable.

+fn('size', '(t: Foldable<any>): number')
  div.description
    p Returns the number of elements in the foldable.

+fn('take', '(n: number, t: Foldable<A>): A[]')
  :markdown-it
    Returns an array of the first `n` elements in the foldable.

+fn('find', '(f: (a: A) => boolean, t: Foldable<A>): Maybe<A>')
  div.description
    p Returns the first element in the foldable that satisfies the predicate.
    pre
      code.language-javascript.
        const isEven = (n) => n % 2 === 0;
        find(isEven, fromArray([1, 3, 4, 5, 6, 7])); //=> just(4)
        find(isEven, fromArray([1, 3, 5, 7])); //=> nothing

+fn('findLast', '(f: (a: A) => boolean, t: Foldable<A>): Maybe<A>')
  div.description
    p Returns the last element in the foldable that satisfies the predicate.
    pre
      code.language-javascript.
        findLast(isEven, fromArray([1, 3, 4, 5, 6, 7])); //=> just(6)

+fn('findIndex', '(f: (a: A) => boolean, t: Foldable<A>): Maybe<number>')
  div.description
    p Returns the index of the first element in the foldable that satisfies the predicate.
    pre
      code.language-javascript.
        findIndex(isEven, fromArray([1, 3, 4, 5, 6, 7])); //=> just(2)
        findIndex(isEven, fromArray([1, 3, 5, 7])); //=> nothing

+fn('findLastIndex', '(f: (a: A) => boolean, t: Foldable<A>): Maybe<number>')
  div.description
    p Returns the index of the last element in the foldable that satisfies the predicate.
    pre
      code.language-javascript.
        findLastIndex(isEven, fromArray([1, 3, 4, 5, 6, 7])); //=> just(4)

+fn('toArray', '(t: Foldable<A>): A[]')
  div.description
    p Converts a foldable to an array.

+fn('sequence_', '<A extends Applicative>(d: ApplicativeDictionary, t: Foldable<A<any>>): A<{}>')
  :markdown-it
    Sequences applicatives in the foldable from left to right discarding the result.

+fn('foldrM', '<A, B, M extends Monad>(f: (a: A, b: B) => M<B>, mb: M<B>, t: Foldable<A>): M<B>')
  div.description
    p Monadic right fold. This function is similair to foldr. The difference is that the accumulator function returns a monadic value and that the final result is in the same monad.
  pre
    code.language-javascript.
      const divide = (a, b) => a === 0 ? nothing : just(b / a);
      foldrM(divide, just(100), fromArray([10, 5])); //=> just(2)
      foldrM(divide, just(100), fromArray([5, 0])); //=> nothing

+h3-section('Traversable')
| Import with.
pre
  code.language-javascript.
    import * as Traversable from "jabz/traversable";

+fn('sequence', '<A, T extends Traversable, F extends Applicative>(a: ApplicativeDictionary, t: T<F<A>>): F<T<A>>')
  div.description
    :markdown-it
      Takes a traversable with applicatives inside and "flips" the nesting so that the applicative ends up on the outside and the traversable on the inside.

      In the example below the applicative `Maybe` the traversable created by `fromArray`.
      Sequence turns them inside out so that `just` floats from the inside to the outside.
  pre
    code.language-javascript.
      sequence(Maybe, fromArray([just(1), just(2), just(3)])); //=> just(fromArray([1, 2, 3]))

+fn('traverse', '<A, B, T extends Traversable, F extends Applicative>(a: ApplicativeDictionary, f: (a: A) => F<B>, t: T<A>): F<T<B>>')
  div.description
    p Traverse.
  pre
    code.language-javascript.
      traverse(Maybe, just, fromArray([1, 2, 3])); //=> just(fromArray([1, 2, 3]))

h2 Instances

include maybe.pug
include either.pug
include conslist.pug
include infinitelist.pug
include writer.pug

h2 Specification

h3 Semigroup

table.spec-table
  tr
    td Description
    td
      p A semigroup represents things that can be combined. That is, two objects of the same semigroups can be combined into one object of the semigroup. In other words semigroups are things that can be composed.
      p Examples are many. For instance numbers can be combined by adding them together, lists can be combined by concatenating them and images can be combined by overlaying them.
  tr
    td Methods
    td
      +method('combine', '(a: A) => A')

h3 Monoid
table.spec-table
  tr
    td Description
    td Monoid extends semigroups with an identity element.
  tr
    td Methods
    td
      +method('identity', '() => A')
  tr
    td Laws
    td.method m.combine*(m.identity()) === m.identity().combine(m) === m
