include mixins.pug

h2 Overview

include:markdown-it overview.md

h2 API

h3#semigroup Semigroup
p Import with.
pre
  code.language-javascript.
    import {combine} from "jabz/semigroup";

+fn('combine', '<A extends Semigroup<A>>(a: A, b: A): A')
  div.description
    p Combines two members of the same semigroup by using their combine method.
  pre
    code.language-javascript.
      combine(sum(3), sum(5)); //=> Sum(8)
      combine("Hello ", "there"); //=> "Hello there"
      combine([1, 2, 3], [4, 5]); //=> [1, 2, 3, 4, 5]

h3#monoid Monoid
p Import with.
pre
  code.language-javascript.
    import * as Monoid from "jabz/monoid";

+fn('identity', '<M extends Monoid<M>>(m: MonoidDictionary<M>): M')
  div.description
    p Takes a monoid dictionary and returns the identity element of the monoid. Alternatively it takes a constructor of one of the native monoid instances.
  pre
    code.language-javascript.
      identity(Sum); //=> Sum(0)
      identity(Array); //=> []
      identity(String); //=> ""

h3#functor Functor
| Import with.
pre
  code.language-javascript.
    import * as Functor from "jabz/functor";

+fn('map', '<F extends Functor, A, B>(f: (a: A) => B, a: F<A>): F<B>')
  div.description
    p Maps a function over a functor.
  pre
    code.language-javascript.
      map((n) => n * n, just(3)); //=> just(9)
      map((n) => n * n, [1, 2, 3]); //=> [1, 4, 9]

+fn('mapTo', '<F extends Functor, A, B>(b: B, as: F<A>): F<B>')
  div.description
    p Replaces each value inside the functor with b.
  pre
    code.language-javascript.
      mapTo(2, just(3)); //=> just(2)
      mapTo(4, [1, 2, 3]); //=> [4, 4, 4]

h3#applicative Applicative
| Import with.
pre
  code.language-javascript.
    import * as Applicative from "jabz/applicative";

h3#monad Monad
p Import with.
pre
  code.language-javascript.
    import * as Monad from "jabz/monad";

+fn('flatten', '<A, M extends Monad>(m: M<M<A>): M<A>')
  div.description
    p Removes one level of nesting from a monad inside a monad.
  pre
    code.language-javascript.
      flatten(just(just(1))); //=> just(1)

+fn('chain', '<A, B, M extends Monad>(f: (a: A) => M<B>, m: M<A>): M<B>')
  div.description
    p Monadic chain.
  pre
    code.language-javascript.
      flatten(just(just(1))); //=> just(1)

h3#foldable Foldable
| Import with.
pre
  code.language-javascript.
    import * as Foldable from "jabz/foldable";

+fn('foldr', '<A, B>(f: (a: A, b: B) => B, init: B, a: Foldable<A> | A[]): B')
  div.description
    p Performs a strict right fold over a foldable.

+fn('size', '(a: Foldable<any>): number')
  div.description
    p Returns the size of a foldable.

+fn('take', '(n: number, t: Foldable<A>): A[]')
  div.description
    p Returns an array of the first n elements in the foldable.

+fn('find', '(f: (a: A) => boolean, t: Foldable<A>): Maybe<A>')
  div.description
    p Returns the first element in the foldable that satisfies the predicate.
    pre
      code.language-javascript.
        const isEven = (n) => n % 2 === 0;
        find(isEven, fromArray([1, 3, 4, 5, 6, 7])); //=> just(4)
        find(isEven, fromArray([1, 3, 5, 7])); //=> nothing

+fn('findLast', '(f: (a: A) => boolean, t: Foldable<A>): Maybe<A>')
  div.description
    p Returns the last element in the foldable that satisfies the predicate.
    pre
      code.language-javascript.
        findLast(isEven, fromArray([1, 3, 4, 5, 6, 7])); //=> just(6)
        findLast(isEven, fromArray([1, 3, 4, 5, 6, 7])); //=> just(6)

+fn('toArary', '(t: Foldable<A>): A[]')
  div.description
    p Converts a foldable to an array.

+fn('sequence_', '<A extends Applicative>(d: ApplicativeDictionary, t: Foldable<A<any>>): A<{}>')
  div.description
    p Returns the last element in the foldable that satisfies the predicate.

+fn('foldrM', '<A, B, M extends Monad>(f: (a: A, b: B) => M<B>, mb: M<B>, t: Foldable<A>): M<B>')
  div.description
    p Monadic right fold. This function is similair to foldr. The difference is that the accumulator function returns a monadic value and that the final result is in the same monad.
  pre
    code.language-javascript.
      const divide = (a, b) => a === 0 ? nothing : just(b / a);
      foldrM(divide, just(100), list([10, 5])); //=> just(2)
      foldrM(divide, just(100), list([5, 0])); //=> nothing

h3#traversable Traversable
| Import with.
pre
  code.language-javascript.
    import * as Traversable from "jabz/traversable";

+fn('sequence', '<A, T extends Traversable, F extends Applicative>(a: ApplicativeDictionary, t: T<F<A>>): F<T<A>>')
  div.description
    :markdown-it
      Takes a traversable with applicatives inside and "flips" the nesting so that the applicative ends up on the outside and the traversable on the inside.

      In the example below the applicative `Maybe` the traversable created by `fromArray`.
      Sequence turns them inside out so that `just` floats from the inside to the outside.
  pre
    code.language-javascript.
      sequence(Maybe, fromArray([just(1), just(2), just(3)])); //=> just(fromArray([1, 2, 3]))

+fn('traverse', '<A, B, T extends Traversable, F extends Applicative>(a: ApplicativeDictionary, f: (a: A) => F<B>, t: T<A>): F<T<B>>')
  div.description
    p Traverse.
  pre
    code.language-javascript.
      traverse(Maybe, just, fromArray([1, 2, 3])); //=> just(fromArray([1, 2, 3]))

h2 Instances

include maybe.pug
include either.pug
include conslist.pug
include infinitelist.pug

h2 Specification

h3 Semigroup

table.spec-table
  tr
    td Description
    td
      p A semigroup represents things that can be combined. That is, two objects of the same semigroups can be combined into one object of the semigroup. In other words semigroups are things that can be composed.
      p Examples are many. For instance numbers can be combined by adding them together, lists can be combined by concatenating them and images can be combined by overlaying them.
  tr
    td Methods
    td
      +method('combine', '(a: A) => A')

h3 Monoid
table.spec-table
  tr
    td Description
    td Monoid extends semigroups with an identity element.
  tr
    td Methods
    td
      +method('identity', '() => A')
  tr
    td Laws
    td.method m.combine*(m.identity()) === m.identity().combine(m) === m
